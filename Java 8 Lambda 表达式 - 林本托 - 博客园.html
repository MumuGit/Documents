<!DOCTYPE html>
<!-- saved from url=(0047)http://www.cnblogs.com/IcanFixIt/p/6744973.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java 8 Lambda 表达式 - 林本托 - 博客园</title>
<link type="text/css" rel="stylesheet" href="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/bundle-CodingLife.css">
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/bundle-CodingLife-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/IcanFixIt/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/IcanFixIt/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/IcanFixIt/wlwmanifest.xml">
<script async="" src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/analytics.js.下载"></script><script src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/jquery.js.下载" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'IcanFixIt', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
“当读书，则读书，心无着于见客也；当见客，则见客，心无着于读书也。一有着，则私也。灵明无着，物来顺应，未来不迎，当时不杂，即过不恋。”
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/IcanFixIt/"><img id="blogLogo" src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/IcanFixIt/">尽信书不如无书</a></h1>
<h2>一介书生，一枚码农；左手诗篇，右手代码。</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/IcanFixIt/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E6%9E%97%E6%9C%AC%E6%89%98">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="http://www.cnblogs.com/IcanFixIt/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="http://www.cnblogs.com/IcanFixIt/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 120&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 69</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/IcanFixIt/p/6744973.html">Java 8 Lambda 表达式</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="cnblogs-markdown"><p><img src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/718178-20170421183310790-1342823400.png"></p>
<h3 id="lambda-是啥玩意">Lambda 是啥玩意</h3>
<p>简单来说，Lambda 就是一个匿名的方法，就这样，没啥特别的。它采用一种非常简洁的方式来定义方法。当你想传递可复用的方法片段时，匿名方法非常有用。例如，将一个方法传递给另外一个方法。</p>
<blockquote>
<p>Tips<br>
其实很多主流语言早已支持 lambda 表达式，例如，Scala，C#，Objective-C，Ruby，C++(11), Python等等。所以也不是啥新玩意儿。</p>
</blockquote>
<h3 id="匿名方法-vs-匿名类">匿名方法 VS 匿名类</h3>
<p>需要谨记一点，<strong>在 Java 里，匿名方法和匿名类并不是相同的</strong>。匿名类仍然需要实例化对象，匿名类虽然没有明确的名字，但它只有是一个对象时才能够使用。<br>
而匿名方法并不需要给它分配实例，方法与作用的数据分离，而对象与它所作用的数据密切相关。</p>
<h3 id="java-中的-lambda-表达式">Java 中的 Lambda 表达式</h3>
<p>在 Java 8之前，一个实现了只有一个抽象方法的接口的匿名类看起来更像Lambda 表达式。下面的代码中，<code>anonymousClass</code>方法调用<code>waitFor</code>方法，参数是一个实现接口的<code>Condition</code>类，实现的功能为，当满足某些条件，Server 就会关闭。<br>
下面的代码是典型的匿名类的使用。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">anonymousClass</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">final</span> Server server = <span class="hljs-keyword">new</span> HttpServer();
    waitFor(<span class="hljs-keyword">new</span> Condition() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">isSatisfied</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> !server.isRunning();
        }
    }</code></pre>
<p>下面的代码用 Lambda 表达式实现相同的功能：</p>
<pre><code class="hljs coffeescript">void closure() { 
     Server server = <span class="hljs-keyword">new</span> HttpServer();
     waitFor(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> !server.isRunning()); 
 }</code></pre>
<p>其实，上面的<code>waitFor</code>方法，更接近于下面的代码的描述：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitFor</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(Condition condition)</span> <span class="hljs-keyword">throws</span>   
    InterruptedException </span>{
        <span class="hljs-keyword">while</span> (!condition.isSatisfied())
            Thread.sleep(<span class="hljs-number">250</span>);
    }
}</code></pre>
<h3 id="一些理论上的区别">一些理论上的区别</h3>
<p>实际上，上面的两种方法的实现都是闭包，后者的实现就是Lambda 表示式。这就意味着两者都需要持有运行时的环境。在 Java 8 之前，这就需要把匿名类所需要的一切复制给它。在上面的例子中，就需要把 <code>server</code> 属性复制给匿名类。</p>
<p>因为是复制，变量必须声明为 final 类型，以保证在获取和使用时不会被改变。Java 使用了优雅的方式保证了变量不会被更新，所以我们不用显式地把变量加上 final 修饰。</p>
<p>Lambda 表达式则不需要拷贝变量到它的运行环境中，从而 Lambda 表达式被当做是一个真正的方法来对待，而不是一个类的实例。</p>
<p>Lambda 表达式不需要每次都要被实例化，对于 Java 来说，带来巨大的好处。不像实例化匿名类，对内存的影响可以降到最小。</p>
<p>总体来说，匿名方法和匿名类存在以下区别：</p>
<ul>
<li>类必须实例化，而方法不必；</li>
<li>当一个类被新建时，需要给对象分配内存；</li>
<li>方法只需要分配一次内存，它被存储在堆的永久区内；</li>
<li>对象作用于它自己的数据，而方法不会；</li>
<li>静态类里的方法类似于匿名方法的功能。</li>
</ul>
<h3 id="一些具体的区别">一些具体的区别</h3>
<p>匿名方法和匿名类有一些具体的区别，主要包括获取语义和覆盖变量。</p>
<h4 id="获取语义">获取语义</h4>
<p>this 关键字是其中的一个语义上的区别。在匿名类中，this 指的是匿名类的实例，例如有了内部类为<code>Foo$InnerClass</code>，当你引用内部类闭包的作用域时，像<code>Foo.this.x</code>的代码看起来就有些奇怪。<br>
在 Lambda 表达式中，this 指的就是闭包作用域，事实上，Lambda 表达式就是一个作用域，这就意味着你不需要从超类那里继承任何名字，或是引入作用域的层级。你可以在作用域里直接访问属性，方法和局部变量。<br>
例如，下面的代码中，Lambda 表达式可以直接访问<code>firstName</code>变量。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Example {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> firstName = <span class="hljs-string">"Tom"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> example() {
        <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; addSurname = surname -&gt; {
            <span class="hljs-comment">// equivalent to this.firstName</span>
            <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">" "</span> + surname;  <span class="hljs-comment">// or even,   </span>
        };
    }
}</code></pre>
<p>这里的<code>firstName</code>就是<code>this.firstName</code>的简写。<br>
但是在匿名类中，你必须显式地调用<code>firstName</code>，</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Example {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> firstName = <span class="hljs-string">"Jerry"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> anotherExample() {
        <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; addSurname = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>,  
        <span class="hljs-built_in">String</span>&gt;() {
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> surname) {
                <span class="hljs-keyword">return</span> Example.this.firstName + <span class="hljs-string">" "</span> + surname;   
            }
        };
    }
}</code></pre>
<h4 id="覆盖变量">覆盖变量</h4>
<p>在 Lambda 表达式中，</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ShadowingExample {

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> firstName = <span class="hljs-string">" Tim"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> shadowingExample(<span class="hljs-built_in">String</span> firstName) {
        <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; addSurname = surname -&gt; {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">" "</span> + surname;
        };
    }
}</code></pre>
<p>因为 this 在Lambda 表达式中，它指向的是一个封闭的作用域，所以<code>this.firstName</code>对应的值是“Tim”，而不是跟它同名的参数的值。如果去掉this，那么引用的则是方法的参数。</p>
<p>在上面的例子中，如果用匿名类来实现的话，<code>firstName</code>指的就是方法的参数；如果想访问最外面的<code>firstName</code>，则使用<code>Example.this.firstName</code>。</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ShadowingExample {

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> firstName = <span class="hljs-string">"King"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> anotherShadowingExample(<span class="hljs-built_in">String</span> firstName) {
        <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; addSurname = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>,  
        <span class="hljs-built_in">String</span>&gt;() {
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> surname) {
                <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">" "</span> + surname;
            }
        };
    }
}</code></pre>
<h3 id="lambda-表达式基本语法">Lambda 表达式基本语法</h3>
<p>Lambda 表达式基本上就是匿名函数块。它更像是内部类的实例。例如，我们想对一个数组进行排序，我们可以使用<code>Arrays.sort</code>方法，它的参数是<code>Comparator</code>接口，类似于下面的代码。</p>
<pre><code class="hljs fortran">Arrays.sort(numbers, new Comparator&lt;<span class="hljs-keyword">Integer</span>&gt;() {
    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compare(<span class="hljs-keyword">Integer</span> first, <span class="hljs-keyword">Integer</span> second) {
        <span class="hljs-keyword">return</span> first.compareTo(second);
    }
});</code></pre>
<p>参数里的<code>Comparator</code>实例就是一个抽象片段，本身没有别的。在这里只有在 <code>sort</code> 方法中被使用。<br>
如果我们用新的语法来替换，用 Lambda 表达式的方式来实现：</p>
<pre><code class="hljs coffeescript">Arrays.sort(numbers, <span class="hljs-function"><span class="hljs-params">(first, second)</span> -&gt;</span> first.compareTo(second));</code></pre>
<p>这种方式更加简洁，实际上，Java 把它当做<code>Comparator</code>类的实例来对待。如果我们把 <code>sort</code>的第二个参数从 Lambda 表达式中抽取出来，它的类型为<code>Comparator&lt;Integer&gt;</code>。</p>
<pre><code class="hljs coffeescript">Comparator&lt;Integer&gt; ascending = <span class="hljs-function"><span class="hljs-params">(first, second)</span> -&gt;</span> first.compareTo(second);
Arrays.sort(numbers, ascending);</code></pre>
<h4 id="语法分解">语法分解</h4>
<p>你可以把单一的抽象方法转换成 Lambda 表达式。<br>
举例，如果我们有一个接口名为<code>Example</code>，里面只有一个抽象方法<code>apply</code>，该抽象方法返回某一类型。</p>
<pre><code class="hljs cs"><span class="hljs-keyword">interface</span> <span class="hljs-title">Example</span> {
     <span class="hljs-function">R <span class="hljs-title">apply</span>(<span class="hljs-params">A args</span>)</span>;
}</code></pre>
<p>我们可以匿名实现此接口里的方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span> Example() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">apply</span><span class="hljs-params">(A args)</span> </span>{
        body
    }
};</code></pre>
<p>转换成 Lambda 表达式的话，我们去掉实例和声明，去掉方法的细节，只保留方法的参数列表和方法体。</p>
<pre><code class="hljs clojure">(<span class="hljs-name">args</span>) {
    body
}</code></pre>
<p>我们引入新的符号（-&gt;）来表示 Lambda 表达式。</p>
<pre><code class="hljs haskell">(args) -&gt; {
    body
}</code></pre>
<p>拿之前排序的方法为例，首先我们用匿名类来实现：</p>
<pre><code class="hljs fortran">Arrays.sort(numbers, new Comparator&lt;<span class="hljs-keyword">Integer</span>&gt;() {
    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compare(<span class="hljs-keyword">Integer</span> first, <span class="hljs-keyword">Integer</span> second) {
        <span class="hljs-keyword">return</span> first.compareTo(second);
    }
});</code></pre>
<p>下一步，去掉实例和方法签名：</p>
<pre><code class="hljs fortran">Arrays.sort(numbers, (<span class="hljs-keyword">Integer</span> first, <span class="hljs-keyword">Integer</span> second) {
    <span class="hljs-keyword">return</span> first.compareTo(second);
});</code></pre>
<p>引用 Lambda 表达式：</p>
<pre><code class="hljs coffeescript">Arrays.sort(numbers, <span class="hljs-function"><span class="hljs-params">(Integer first, Integer second)</span> -&gt;</span> {
    <span class="hljs-keyword">return</span> first.compareTo(second);
});</code></pre>
<p>完成！但有些地方可以进一步优化。你可以去掉参数的类型，编译器已经足够聪明知道参数的类型。</p>
<pre><code class="hljs coffeescript">Arrays.sort(numbers, <span class="hljs-function"><span class="hljs-params">(first, second)</span> -&gt;</span> {
    <span class="hljs-keyword">return</span> first.compareTo(second);
});</code></pre>
<p>如果是一个简单的表达式的话，例如只有一行代码，你可以去掉方法体的大括号，如果有返回值的话，return 关键字也可以去掉。</p>
<pre><code class="hljs coffeescript">Arrays.sort(numbers, <span class="hljs-function"><span class="hljs-params">(first, second)</span> -&gt;</span> first.compareTo(second));</code></pre>
<p>如果Lambda 只有一个参数的话，参数外面的小括号也可以去掉。</p>
<pre><code class="hljs lisp">(<span class="hljs-name">x</span>) -&gt; x + <span class="hljs-number">1</span></code></pre>
<p>去掉小括号后，</p>
<pre><code class="hljs nginx"><span class="hljs-attribute">x</span> -&gt; x + <span class="hljs-number">1</span></code></pre>
<p>下一步我们做下总结，</p>
<pre><code class="hljs go">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; { <span class="hljs-keyword">return</span> x + y; }
(x, y) -&gt; { <span class="hljs-keyword">return</span> x + y; }
(x, y) -&gt; x + y; x -&gt; x * <span class="hljs-number">2</span>
() -&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Hello"</span>);
System.out::<span class="hljs-built_in">println</span>;</code></pre>
<p>第一个方式是完整的 Lambda 的声明和使用的方式，不过有些冗余，其实，参数的类型可以省略；<br>
第二个方式是去掉参数类型的 Lambda 表达式；<br>
第三个方式是，如果你的方法体只有一行语句，你可以直接省略掉大括号和 return 关键字；<br>
第四个方式是没有参数的 Lambda 表达式；<br>
第五个方式是Lambda 表达式的变种：是Lambda 表达式的一种简写，称为方法引用。例如：</p>
<pre><code class="hljs css"> <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println</span>;</code></pre>
<p>实际上它是下面Lambda 表达式的一种简写：</p>
<pre><code class="hljs fortran">(<span class="hljs-keyword">value</span> -&gt; System.<span class="hljs-keyword">out</span>.prinltn(<span class="hljs-keyword">value</span>)</code></pre>
<h3 id="深入-lambda表达式">深入 Lambda表达式</h3>
<h4 id="函数式接口">函数式接口</h4>
<p>Java 把 Lambda表达式当作是一个接口类型的实例。它把这种形式被称之为函数式接口。一个函数式接口就是一个只有单一方法的接口，Java把这种方法称之为“函数式方法”，但更常用的名字为单一抽象方法（single abstract method" 或 SAM）。例如JDK中存在的接口例如<code>Runnable</code>和<code>Callable</code>。</p>
<h5 id="functionalinterface">@FunctionalInterface</h5>
<p>Oracle 引入了一个新的注解为<code>@FunctionalInterface</code>， 用来标识一个接口为函数式接口。它基本上是用来传达这一用途，除此而外，编辑器还会做一些额外的检查。<br>
比如，下面的接口：</p>
<pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">FunctionalInterfaceExample</span> {
    <span class="hljs-comment">// compiles ok</span>
}</code></pre>
<p>如果加上<code>@FunctionalInterface</code>注解，则会编译错误：</p>
<pre><code class="hljs groovy"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// &lt;- error here</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FunctionalInterfaceExample</span> {</span>
      <span class="hljs-comment">// doesn't compile</span>
}</code></pre>
<p>编译器就会报错，错误的详细信息为“Invalid <a href="mailto:&#39;@functionalinterface">'@FunctionalInterface</a>' annotation; FunctionalInterfaceExample is not a functional interface”。意思是没有定义一个单一的抽象方法。<br>
而如果我们定义了两个抽象方法会如何？</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FunctionalInterfaceExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">illegal</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// &lt;- error here</span>
}</code></pre>
<p>编译器再次报错，提示为"multiple, non-overriding abstract methods were found"。所以，一旦使用了此注解，则在接口里只能定义一个抽象方法。</p>
<p>而现在有这样一种情况，如歌一个接口继承了另一个接口，会怎么办？我们创建一个新的函数式接口为A，定义了另一个接口B，B继承A，则B仍然是一个函数式接口，它继承了A的<code>apply</code>方法。</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{</code></pre>
<p>如果你想看起来更加清晰，可以复写父类的方法：</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
}</code></pre>
<p>我们可以用下面的代码来测试一下上面的两个接口是否为函数式接口：</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
   A a = () -&gt; System.out.println(<span class="hljs-string">"A"</span>);
   B b = () -&gt; System.out.println(<span class="hljs-string">"B"</span>);
   a.apply(); <span class="hljs-comment">// 打印：A</span>
   b.apply(); <span class="hljs-comment">// 打印：B</span>
}</code></pre>
<p>如果B接口继承了A接口，那么在B接口中就不能定义新的方法了，否则编译器会报错。</p>
<p>除了这些，在Java 8 中接口有了一些新的改进：</p>
<ul>
<li>可以添加默认方法；</li>
<li>可以包含静态接口方法；</li>
<li>在<code>java.util.function</code>包中增加了一些新的接口，例如，<code>Function</code> 和 <code>Predicate</code>。</li>
</ul>
<h4 id="方法引用">方法引用</h4>
<p>简单来说，方法引用就是 Lambda 表达式的一种简写。当你创建一个 Lambda 表达式时，你创建了一个匿名方法并提供方法体，但你使用方法引用时，你只需要提供已经存在的方法的名字，它本身已经包含方法体。<br>
它的基本语法如下；</p>
<pre><code class="hljs cpp">Class::method</code></pre>
<p>或一个更加简洁明了的例子：</p>
<pre><code class="hljs cpp">String::valueOf</code></pre>
<p>"::"符号前面表示的是目标引用，后面表示方法的名字。所以，在上面的例子，String 类作为目标类，用来寻找它的方法<code>valueOf</code>，我们指的就是 String 类上的静态方法。</p>
<pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> valueOf(<span class="hljs-keyword">Object</span> obj) <span class="hljs-comment">{ ... }</span></code></pre>
<p>"::"称之为定界符，当我们使用它的时候，只是用来引用要使用的方法，而不是调用方法，所以不能在方法后面加()。<br>
<code>String::valueOf(); // error</code><br>
你不能直接调用方法引用，只是用来替代 Lambda 表达式，所以，哪里使用 Lambda 表达式了，哪里就可以使用方法引用了。<br>
所以，下面的代码并不能运行：</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
    String::valueOf;
}</code></pre>
<p>这是因为该方法引用不能转化为Lambda 表达式，因为编译器没有上下文来推断要创建哪种类型的Lambda。<br>
我们知道这个引用其实是等同于下面的代码：</p>
<pre><code class="hljs delphi">(x) -&gt; <span class="hljs-keyword">String</span>.valueOf(x)</code></pre>
<p>但编译器还不知道。虽然它可以知道一些事情。它知道，作为一个Lambda，返回值应该是字符串类型，因为valueOf方法的返回值为字符串类型。但它不知道作为论据需要提供什么信息。我们需要给它一点帮助，给它更多的上下文信息。<br>
下面我们创建一个函数式接口<code>Conversion</code>，</p>
<pre><code class="hljs typescript">@FunctionalInterface
<span class="hljs-keyword">interface</span> Conversion {
    <span class="hljs-built_in">String</span> convert(Integer <span class="hljs-built_in">number</span>);
}</code></pre>
<p>接下来我们需要创建一个场景去使用这个接口作为一个 Lambda，我们定义了下面的方法：</p>
<pre><code class="hljs fortran"><span class="hljs-keyword">public</span> static String convert(<span class="hljs-keyword">Integer</span> <span class="hljs-keyword">number</span>, Conversion <span class="hljs-function"><span class="hljs-keyword">function</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>.<span class="hljs-title">convert</span><span class="hljs-params">(number)</span></span>;
}</code></pre>
<p>其实，我们已经给编译器提供了足够多的信息，可以把一个方法引用转换成一个等同的 Lambda。当我们调用<code>convert</code>方法时，我们可以把如下代码传递给 Lambda。</p>
<pre><code class="hljs lisp">convert(<span class="hljs-number">100</span>, (<span class="hljs-name">number</span>) -&gt; String.valueOf(<span class="hljs-name">number</span>))<span class="hljs-comment">;</span></code></pre>
<p>我们可以用把上面的 Lambda 替换为方法引用，</p>
<pre><code class="hljs lisp">convert(<span class="hljs-number">100</span>, String:<span class="hljs-symbol">:valueOf</span>)<span class="hljs-comment">;</span></code></pre>
<p>另一种方式是我们告诉编译器，把引用分配给一个类型：</p>
<pre><code class="hljs typescript">Conversion b = (<span class="hljs-built_in">number</span>) -&gt; <span class="hljs-built_in">String</span>.valueOf(<span class="hljs-built_in">number</span>);</code></pre>
<p>用方法引用来表示：</p>
<pre><code class="hljs cpp">Conversion b = String::valueOf</code></pre>
<h4 id="方法引用的种类">方法引用的种类</h4>
<p>在 Java 中，有四种方法引用的类型：</p>
<ul>
<li>构造方法引用；</li>
<li>静态方法引用：</li>
<li>两种实例方法引用。</li>
</ul>
<p>最后两个有点混乱。第一种是特定对象的方法引用，第二个是任意对象的方法引用，而是特定类型的方法引用。区别在于你想如何使用该方法，如果你事先并不知道有没有实例。</p>
<h4 id="构造方法引用">构造方法引用</h4>
<p>构造方法的基本引用如下：</p>
<pre><code class="hljs cpp">String::<span class="hljs-keyword">new</span></code></pre>
<p>它会创建一个 Lambda 表达式，然后调用String 无参的构造方法。<br>
它实际上等同于：</p>
<pre><code class="hljs javascript">() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>()</code></pre>
<p>需要注意的是构造方法引用没有括号，它只是引用，并不是调用，上面的例子只是引用了 String类的构造方法，并没有真正去实例化一个字符串对象。<br>
接下来我们看一个实际应用构造方法引用的例子。<br>
看先的例子，循环十遍为 list 增加对象。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
    List&lt;Object&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> Object());
  }
}</code></pre>
<p>如果我们想复用实例化的功能，我们可以抽取出一个新的方法<code>initialise</code>用<code>factory</code>创建对象。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
    List&lt;Object&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    initialise(<span class="hljs-built_in">list</span>, ...);
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialise</span><span class="hljs-params">(List&lt;Object&gt; <span class="hljs-built_in">list</span>, Factory&lt;Object&gt; factory)</span></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-built_in">list</span>.add(factory.create());
    }
 }</code></pre>
<p><code>Factory</code>是一个函数式接口，包含一个<code>create</code>方法，此方法返回 Object 对象，我们可以用 Lambda 的方式向 list 中添加对象。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
    List&lt;Object&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    initialise(<span class="hljs-built_in">list</span>, () -&gt; <span class="hljs-keyword">new</span> Object());
}</code></pre>
<p>或者我们用构造方法引用的方式来替换：</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
    List&lt;Object&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    initialise(<span class="hljs-built_in">list</span>, Object::<span class="hljs-keyword">new</span>);
}</code></pre>
<p>上面的方法其实还有待改进，上面只是创建 Object 类型的对象，我们可以增加泛型，实现可以创建更多类型的方法。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
    List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    initialise(<span class="hljs-built_in">list</span>, String::<span class="hljs-keyword">new</span>);
}

<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialise</span><span class="hljs-params">(List&lt;T&gt; <span class="hljs-built_in">list</span>, Factory&lt;T&gt; factory)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-built_in">list</span>.add(factory.create());
    }
}</code></pre>
<p>到现在为知，我们演示的都是无参的构造方法的引用，如果是带有参数的构造方法的引用该如何处理呢？<br>
当有多个构造函数时，使用相同的语法，但编译器计算出哪个构造函数是最佳匹配。它基于目标类型和推断功能接口，它可以用来创建该类型。<br>
例如，我们有个 Person 类，它有一个多个参数的构造方法。</p>
<pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Person</span> {
    public <span class="hljs-type">Person</span>(<span class="hljs-type">String</span> <span class="hljs-title">forename</span>, <span class="hljs-type">String</span> <span class="hljs-title">surname</span>, <span class="hljs-type">LocalDate</span>    
    <span class="hljs-title">birthday</span>, <span class="hljs-type">Sex</span> <span class="hljs-title">gender</span>, <span class="hljs-type">String</span> <span class="hljs-title">emailAddress</span>, <span class="hljs-title">int</span> <span class="hljs-title">age</span>) {
      // ...
    }</span></code></pre>
<p>回到上面的例子，我们可以如下使用：</p>
<pre><code class="hljs lisp">initialise(<span class="hljs-name">people</span>, () -&gt; new Person(<span class="hljs-name">forename</span>, surname, birthday,
                                    gender, email, age))<span class="hljs-comment">;</span></code></pre>
<p>但是如果想使用这个构造方法引用，则需要 Lambda 表达式提供如下参数：</p>
<pre><code class="hljs lisp">initialise(<span class="hljs-name">people</span>, () -&gt; new Person(<span class="hljs-name">forename</span>, surname, birthday,
                                    gender, email, age))<span class="hljs-comment">;</span></code></pre>
<h4 id="特定对象的方法引用">特定对象的方法引用</h4>
<p>下面是特定对象的方法引用的例子：</p>
<pre><code class="hljs cpp">x::toString</code></pre>
<p><code>x</code>就是我们想要得到的对象。它等同于下面的Lambda 表达式。</p>
<pre><code class="hljs swift">() -&gt; x.<span class="hljs-built_in">toString</span>()</code></pre>
<p>这种方法引用可以为我们提供便利的方式在不同的函数式接口类型中进行切换。看例子：</p>
<pre><code class="hljs coffeescript">Callable&lt;String&gt; c = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-string">"Hello"</span>;</code></pre>
<p><code>Callable</code>的方法为<code>call</code>，当被调用时返回“Hello”。<br>
如果我们有另外一个函数式接口<code>Factory</code>，我们可以使用方法引用的方式来转变<code>Callable</code>这个函数式接口。</p>
<pre><code class="hljs dts">Factory<span class="hljs-params">&lt;String&gt;</span> f = <span class="hljs-symbol">c::</span>call;</code></pre>
<p>我们可以重新创建一个 Lambda表达式，但是这个技巧是重用预定义的Lambda的一个有用的方式。 将它们分配给变量并重用它们以避免重复。<br>
我们有下面一个例子：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> example() {
    <span class="hljs-built_in">String</span> x = <span class="hljs-string">"hello"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x::toString</span>)</span>;
}</code></pre>
<p>这个例子中方法引用使用了闭包。他创建了一个 Lambda用来调用<code>x</code>对象上的<code>toString</code>方法。<br>
上面<code>function</code>方法的签名和实现如下所示：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Supplier&lt;<span class="hljs-built_in">String</span>&gt; supplier</span>) </span>{
    <span class="hljs-keyword">return</span> supplier.get();
}</code></pre>
<p>函数式接口<code>Supplier</code>的定义如下：</p>
<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;
}</code></pre>
<p>当使用此方法时，它通过<code>get</code>方法返回一个字符串，而且这是唯一的在我们的结构中获取字符串的方式。它等同于：</p>
<pre><code class="hljs php"><span class="hljs-keyword">public</span> void example() {
  String x = <span class="hljs-string">""</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-params">()</span> -&gt; x.toString<span class="hljs-params">()</span>)</span></span>;
}</code></pre>
<p>需要注意的是，这里的 Lambda 表达式没有参数。这表明<code>x</code>变量在Lambda的局部作用域里是不可用的，如果可用必须要放在它的作用域之外。我们必须要掩盖变量<code>x</code>。<br>
如果用匿名类来实现的话，应该是下面的样子，这些需要主意，<code>x</code>变量是如何传递的。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span> </span>{
    String x = <span class="hljs-string">""</span>;
    function(<span class="hljs-keyword">new</span> Supplier&lt;String&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> x.toString(); <span class="hljs-comment">// &lt;- closes over 'x'</span>
        }
    });
}</code></pre>
<h4 id="任意对象的实例方法引用实例随后提供">任意对象的实例方法引用（实例随后提供）</h4>
<p>最后一种类型的实例方法引用的格式是这样的：</p>
<pre><code class="hljs cpp">Object::toString</code></pre>
<p>尽管在“::”左边指向的是一个类（有点类似于静态方法引用），实际上它是指向一个对象，<code>toString</code>方法是<code>Object</code>类上的实例方法，不是静态方法。您可能不使用常规实例方法语法的原因是，还没有引用的实例。<br>
在以前，当我们调用<code>x::toString</code>时，我们是知道<code>x</code>的类型，但是有些情况我们是不知道的，但你仍然可以传递一个方法引用，但是在后面使用此语法时需要提供对应的类型。<br>
例如，下面的表达式等同于<code>x</code>没有限制的类型。</p>
<pre><code class="hljs swift">(x) -&gt; x.<span class="hljs-built_in">toString</span>()</code></pre>
<p>有两种不同的实例方法的引用基本是学术上的。有时候，你需要传递一些东西，其他时候，Lambda 的用法会为你提供。<br>
这个例子类似于一个常规的方法引用；它这次调用String 对象的<code>toString</code>方法，该字符串提供给使用 Lambda 的函数，而不是从外部作用域传递的函数。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lambdaExample</span><span class="hljs-params">()</span> </span>{
    function(<span class="hljs-string">"value"</span>, String::toString);
}</code></pre>
<p>这个<code>String</code>看起来像是引用一个类，其实是一个实例。是不是有些迷惑，为了能清晰一些，我们需要看一个使用 Lambda 表达式的方法，如下：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> value, <span class="hljs-built_in">Function</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">function</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">value</span>)</span>;
}</code></pre>
<p>所以，这个 String 实例直接传递给了方法，它看起来像一个完全合格的Lambda。</p>
<pre><code class="hljs php"><span class="hljs-keyword">public</span> void lambdaExample() {
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-string">"value"</span>, x -&gt; x.toString<span class="hljs-params">()</span>)</span></span>;
}</code></pre>
<p>上面的代码可以简写成<code>String::toString</code>， 它是在说在运行时给我提供对象实例。<br>
如果你想用匿名类展开加以理解，它是这个样子的。参数<code>x</code>是可用的并没有被遮蔽，所以它更像是Lambda 表达式而不是闭包。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lambdaExample</span><span class="hljs-params">()</span> </span>{
    function(<span class="hljs-string">"value"</span>, <span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
      <span class="hljs-meta">@Override</span>
      <span class="hljs-comment">// takes the argument as a parameter, doesn't need to close </span>
      <span class="hljs-function">over it
      <span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String x)</span> </span>{
        <span class="hljs-keyword">return</span> x.toString();
      }
    });
}</code></pre>
<h4 id="方法引用的总结">方法引用的总结</h4>
<p>Oracle描述了四种类型的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">方法引用</a>，如下所示。</p>
<table>
<thead>
<tr class="header">
<th>种类</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>静态方法引用</td>
<td><code>ContainingClass::staticMethodName</code></td>
</tr>
<tr class="even">
<td>特定对象的实例方法引用</td>
<td><code>ContainingObject::instanceMethodName</code></td>
</tr>
<tr class="odd">
<td>特定类型的任意对象的实例方法引用</td>
<td><code>ContainingType::methodName</code></td>
</tr>
<tr class="even">
<td>构造方法引用</td>
<td><code>ClassName::new</code></td>
</tr>
</tbody>
</table>
<p>下面是方法引用的语法和具体的例子。</p>
<table>
<thead>
<tr class="header">
<th>种类</th>
<th>语法</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>静态方法引用</td>
<td>Class::staticMethodName</td>
<td><code>String::valueOf</code></td>
</tr>
<tr class="even">
<td>特定对象的实例方法引用</td>
<td>object::instanceMethodName</td>
<td><code>x::toString</code></td>
</tr>
<tr class="odd">
<td>特定类型的任意对象的实例方法引用</td>
<td>Class::instanceMethodName</td>
<td><code>String::toString</code></td>
</tr>
<tr class="even">
<td>构造方法引用</td>
<td>ClassName::new</td>
<td><code>String::new</code></td>
</tr>
</tbody>
</table>
<p>最后，上面的方法引用等同于下面对应的 Lambda 表达式。</p>
<table>
<thead>
<tr class="header">
<th>种类</th>
<th>语法</th>
<th>Lambda</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>静态方法引用</td>
<td>Class::staticMethodName</td>
<td><code>(s) -&gt; String.valueOf(s)</code></td>
</tr>
<tr class="even">
<td>特定对象的实例方法引用</td>
<td>object::instanceMethodName</td>
<td><code>() -&gt; "hello".toString()</code></td>
</tr>
<tr class="odd">
<td>特定类型的任意对象的实例方法引用</td>
<td>Class::instanceMethodName</td>
<td><code>(s) -&gt; s.toString()</code></td>
</tr>
<tr class="even">
<td>构造方法引用</td>
<td>ClassName::new</td>
<td><code>() -&gt; new String()</code></td>
</tr>
</tbody>
</table>
<p>目前为止，Labmbda 的主要内容已经介绍完毕。</p>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag">标签: <a href="http://www.cnblogs.com/IcanFixIt/tag/Java/">Java</a>, <a href="http://www.cnblogs.com/IcanFixIt/tag/Java%208/">Java 8</a></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(6744973,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;5a00e3ff-79a5-e411-b908-9dcfd8948a71&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/IcanFixIt/" target="_blank"><img src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/20170204175715.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/IcanFixIt/">林本托</a><br>
            <a href="http://home.cnblogs.com/u/IcanFixIt/followees">关注 - 6</a><br>
            <a href="http://home.cnblogs.com/u/IcanFixIt/followers">粉丝 - 28</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;5a00e3ff-79a5-e411-b908-9dcfd8948a71&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(6744973,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">7</span>
    </div>
    <div class="buryit" onclick="votePost(6744973,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
</div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/IcanFixIt/p/6731638.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/IcanFixIt/p/6731638.html" title="发布于2017-04-19 09:15">SAML</a><br><a href="http://www.cnblogs.com/IcanFixIt/p/6769571.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/IcanFixIt/p/6769571.html" title="发布于2017-04-26 17:11">Linux Shell——bash shell 脚本简介</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2017-04-21 18:34</span> <a href="http://www.cnblogs.com/IcanFixIt/">林本托</a> 阅读(<span id="post_view_count">574</span>) 评论(<span id="post_comment_count">0</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6744973" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html#" onclick="AddToWz(6744973);return false;">收藏</a></div>
	</div>
	<script src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/highlight.min.js.下载"></script><script>markdown_highlight();</script><script type="text/javascript">var allowComments=true,cb_blogId=213568,cb_entryId=6744973,cb_blogApp=currentBlogApp,cb_blogUserGuid='5a00e3ff-79a5-e411-b908-9dcfd8948a71',cb_entryCreatedDate='2017/4/21 18:34:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank">【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br><a href="http://www.gcpowertools.com.cn/products/activereports/excel.htm?utm_source=cnblogs&amp;utm_medium=blogpage&amp;utm_term=bottom&amp;utm_content=AR&amp;utm_campaign=community" target="_blank">【报表】Excel 报表开发18 招式，人人都能做报表</a><br><a href="http://click.aliyun.com/m/15483" target="_blank">【活动】阿里云海外云服务全面降价助力企业全球布局</a><br><a href="https://group.cnblogs.com/topic/76829.html" target="_blank">【实用】40+篇云服务器操作及运维基础知识！</a><br></div>
<div id="opt_under_post"></div>
<div id="cnblogs_c1" class="c_ad_block"></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="http://news.cnblogs.com/n/570427/" target="_blank">从网易严选毛巾事件，看互联网撕逼的12个暗黑法则</a><br> ·  <a href="http://news.cnblogs.com/n/570426/" target="_blank">马云李彦宏数博会上"隔空对战" 马化腾来“劝架”了</a><br> ·  <a href="http://news.cnblogs.com/n/570425/" target="_blank">小米转型里程碑！小米之家突破100家：端午一天开四家</a><br> ·  <a href="http://news.cnblogs.com/n/570424/" target="_blank">看到AlphaGo难免想起“深蓝”？可IBM当年前赢得并不光彩</a><br> ·  <a href="http://news.cnblogs.com/n/570423/" target="_blank">知道苹果有多值钱吗？市值超瑞士、荷兰等国GDP</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="cnblogs_c2" class="c_ad_block"><a href="http://click.aliyun.com/m/17215/" target="_blank"><img width="468" height="60" src="./Java 8 Lambda 表达式 - 林本托 - 博客园_files/24442-20170417123605337-535991337.jpg" alt="阿里云E4"></a></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/569992/" target="_blank">程序员的工作、学习与绩效</a><br> ·  <a href="http://kb.cnblogs.com/page/569056/" target="_blank">软件开发为什么很难</a><br> ·  <a href="http://kb.cnblogs.com/page/565901/" target="_blank">唱吧DevOps的落地，微服务CI/CD的范本技术解读</a><br> ·  <a href="http://kb.cnblogs.com/page/566523/" target="_blank">程序员，如何从平庸走向理想？</a><br> ·  <a href="http://kb.cnblogs.com/page/566318/" target="_blank">我为什么鼓励工程师写blog</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"><b>历史上的今天:</b><br>2015-04-21 <a href="http://www.cnblogs.com/IcanFixIt/p/4444237.html">在Eclipse新建菜单中添加JSP</a><br></div>
<script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><div id="profile_block">昵称：<a href="http://home.cnblogs.com/u/IcanFixIt/">林本托</a><br>园龄：<a href="http://home.cnblogs.com/u/IcanFixIt/" title="入园时间：2015-01-27">2年4个月</a><br>粉丝：<a href="http://home.cnblogs.com/u/IcanFixIt/followers/">28</a><br>关注：<a href="http://home.cnblogs.com/u/IcanFixIt/followees/">6</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;5a00e3ff-79a5-e411-b908-9dcfd8948a71&#39;)">+加关注</a></div></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2017/04/01&#39;);return false;">&lt;</a></td><td align="center">2017年5月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2017/06/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/02.html"><u>2</u></a></td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td class="CalWeekendDay" align="center">6</td></tr><tr><td class="CalWeekendDay" align="center">7</td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/08.html"><u>8</u></a></td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td class="CalWeekendDay" align="center">13</td></tr><tr><td class="CalWeekendDay" align="center">14</td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/15.html"><u>15</u></a></td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalWeekendDay" align="center">20</td></tr><tr><td class="CalWeekendDay" align="center">21</td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/22.html"><u>22</u></a></td><td align="center">23</td><td align="center">24</td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/25.html"><u>25</u></a></td><td align="center"><a href="http://www.cnblogs.com/IcanFixIt/archive/2017/05/26.html"><u>26</u></a></td><td class="CalWeekendDay" align="center">27</td></tr><tr><td class="CalWeekendDay" align="center">28</td><td class="CalTodayDay" align="center">29</td><td align="center">30</td><td align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<div class="catListLink">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/IcanFixIt/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div></div><div id="sidebar_toptags" class="sidebar-block">
<div class="catListTag">
<h3 class="catListTitle">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/IcanFixIt/tag/Java/">Java</a>(48)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/%E8%AF%BB%E4%B9%A6/">读书</a>(18)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/Groovy/">Groovy</a>(7)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/Guava/">Guava</a>(7)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/OS%20X/">OS X</a>(6)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/Java%208/">Java 8</a>(5)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/Linux/">Linux</a>(4)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/%E6%83%B3%E6%B3%95/">想法</a>(4)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/shell/">shell</a>(3)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/Maven/">Maven</a>(3)</li><li><a href="http://www.cnblogs.com/IcanFixIt/tag/">更多</a></li>
</ul>
</div></div><div id="sidebar_categories">
<div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
<h3 class="catListTitle">随笔档案</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/IcanFixIt/archive/2017/05.html">2017年5月 (6)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/IcanFixIt/archive/2017/04.html">2017年4月 (8)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/IcanFixIt/archive/2017/03.html">2017年3月 (6)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/IcanFixIt/archive/2017/02.html">2017年2月 (9)</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/IcanFixIt/archive/2016/12.html">2016年12月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/IcanFixIt/archive/2016/09.html">2016年9月 (3)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/IcanFixIt/archive/2016/08.html">2016年8月 (4)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/IcanFixIt/archive/2016/07.html">2016年7月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_8" href="http://www.cnblogs.com/IcanFixIt/archive/2016/03.html">2016年3月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_9" href="http://www.cnblogs.com/IcanFixIt/archive/2016/02.html">2016年2月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_10" href="http://www.cnblogs.com/IcanFixIt/archive/2016/01.html">2016年1月 (4)</a> </li>

<li><a id="CatList_LinkList_0_Link_11" href="http://www.cnblogs.com/IcanFixIt/archive/2015/11.html">2015年11月 (2)</a> </li>

<li><a id="CatList_LinkList_0_Link_12" href="http://www.cnblogs.com/IcanFixIt/archive/2015/10.html">2015年10月 (5)</a> </li>

<li><a id="CatList_LinkList_0_Link_13" href="http://www.cnblogs.com/IcanFixIt/archive/2015/09.html">2015年9月 (6)</a> </li>

<li><a id="CatList_LinkList_0_Link_14" href="http://www.cnblogs.com/IcanFixIt/archive/2015/08.html">2015年8月 (10)</a> </li>

<li><a id="CatList_LinkList_0_Link_15" href="http://www.cnblogs.com/IcanFixIt/archive/2015/07.html">2015年7月 (9)</a> </li>

<li><a id="CatList_LinkList_0_Link_16" href="http://www.cnblogs.com/IcanFixIt/archive/2015/06.html">2015年6月 (2)</a> </li>

<li><a id="CatList_LinkList_0_Link_17" href="http://www.cnblogs.com/IcanFixIt/archive/2015/05.html">2015年5月 (8)</a> </li>

<li><a id="CatList_LinkList_0_Link_18" href="http://www.cnblogs.com/IcanFixIt/archive/2015/04.html">2015年4月 (2)</a> </li>

<li><a id="CatList_LinkList_0_Link_19" href="http://www.cnblogs.com/IcanFixIt/archive/2015/03.html">2015年3月 (10)</a> </li>

<li><a id="CatList_LinkList_0_Link_20" href="http://www.cnblogs.com/IcanFixIt/archive/2015/02.html">2015年2月 (13)</a> </li>

<li><a id="CatList_LinkList_0_Link_21" href="http://www.cnblogs.com/IcanFixIt/archive/2015/01.html">2015年1月 (9)</a> </li>

</ul>

</div>

</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/IcanFixIt/p/6909338.html#3701682">1. Re:在Eclipse IDE使用Gradle构建应用程序</a></li>
        <li class="recent_comment_body">Gradle比maven优秀的地方在哪</li>
        <li class="recent_comment_author">--嫩江姑爷</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/IcanFixIt/p/6858887.html#3693910">2. Re:个人对习惯培养的拙见</a></li>
        <li class="recent_comment_body">赞</li>
        <li class="recent_comment_author">--YOUSAY</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/IcanFixIt/p/6858887.html#3693570">3. Re:个人对习惯培养的拙见</a></li>
        <li class="recent_comment_body">制定一个好的生活方式，坚持21天，变成习惯就好了。</li>
        <li class="recent_comment_author">--Amberlyn</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/IcanFixIt/p/6858887.html#3693155">4. Re:个人对习惯培养的拙见</a></li>
        <li class="recent_comment_body">不错，习惯在于坚持！</li>
        <li class="recent_comment_author">--幕三少</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/IcanFixIt/p/6782513.html#3693099">5. Re:Linux Shell——流程控制</a></li>
        <li class="recent_comment_body">@牛顿的小脑多谢多谢，我会努力做得更好。...</li>
        <li class="recent_comment_author">--林本托</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="http://www.cnblogs.com/IcanFixIt/p/6476798.html">1. 我问我自己，你究竟想成为一个什么样的人？(3369)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6690478.html">2. Java 9 尝鲜之JShell交互式编程环境(2586)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6364085.html">3. 代码天天写，快乐天天有！(1064)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/4838375.html">4. Java 7 中 NIO.2 的使用——第四节 文件和目录(863)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6606641.html">5. 1年内实现梦想的21个方式(797)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock"><ul><li><a href="http://www.cnblogs.com/IcanFixIt/p/6476798.html">1. 我问我自己，你究竟想成为一个什么样的人？(39)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6690478.html">2. Java 9 尝鲜之JShell交互式编程环境(10)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6858887.html">3. 个人对习惯培养的拙见(9)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6782513.html">4. Linux Shell——流程控制(6)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6822971.html">5. 书店寻宝记(2)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">推荐排行榜</h3>
<div id="TopDiggPostsBlock"><ul><li><a href="http://www.cnblogs.com/IcanFixIt/p/6476798.html">1. 我问我自己，你究竟想成为一个什么样的人？(51)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6690478.html">2. Java 9 尝鲜之JShell交互式编程环境(8)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6606641.html">3. 1年内实现梦想的21个方式(7)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html">4. Java 8 Lambda 表达式(7)</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6858887.html">5. 个人对习惯培养的拙见(7)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2017 林本托
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
Fake it till you make it.
<!--PageEndHtml Block End-->


</body></html>